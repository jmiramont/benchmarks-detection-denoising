<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>benchmark_demo.utilstf &mdash; Benchmarks of Multicomponent Signal Methods  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Benchmarks of Multicomponent Signal Methods
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">benchmark_demo</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Benchmarks of Multicomponent Signal Methods</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">benchmark_demo.utilstf</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for benchmark_demo.utilstf</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; This file contains a number of utilities for time-frequency analysis. </span>
<span class="sd">Some functions has been modified from the supplementary code of:</span>
<span class="sd">Bardenet, R., Flamant, J., &amp; Chainais, P. (2020). &quot;On the zeros of the spectrogram of </span>
<span class="sd">white noise.&quot; Applied and Computational Harmonic Analysis, 48(2), 682-705.</span>

<span class="sd">Those functions are:</span>
<span class="sd">- getSpectrogram(signal)</span>
<span class="sd">- findCenterEmptyBalls(Sww, pos_exp, radi_seg=1)</span>
<span class="sd">- getConvexHull(Sww, pos_exp, empty_mask, radi_expand=0.5)</span>
<span class="sd">- reconstructionSignal(hull_d, stft)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sg</span>
<span class="kn">from</span> <span class="nn">scipy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">complex128</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">pi</span> <span class="k">as</span> <span class="n">pi</span>
<div class="viewcode-block" id="get_gauss_window"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.get_gauss_window">[docs]</a><span class="k">def</span> <span class="nf">get_gauss_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">prec</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
    <span class="n">l</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">Nfft</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span><span class="o">/</span><span class="n">pi</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">tmt0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">t0</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">tmt0</span><span class="o">/</span><span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span>    
    <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="get_round_window"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.get_round_window">[docs]</a><span class="k">def</span> <span class="nf">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">prec</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Generates a round Gaussian window, i.e. same essential support in time and </span>
<span class="sd">    frequency: g(n) = exp(-pi*(n/T)^2) for computing the Short-Time Fourier Transform.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        Nfft: Number of samples of the desired fft.</span>

<span class="sd">    Returns:</span>
<span class="sd">        g (ndarray): A round Gaussian window.</span>
<span class="sd">        T (float): The scale of the Gaussian window (T = sqrt(Nfft))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># analysis window</span>
    <span class="n">L</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>
    <span class="n">l</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">Nfft</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span><span class="o">/</span><span class="n">pi</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
 
    <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">tmt0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">t0</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">tmt0</span><span class="o">/</span><span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span>    
    <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">L</span></div>

<div class="viewcode-block" id="get_stft"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.get_stft">[docs]</a><span class="k">def</span> <span class="nf">get_stft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">Nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">xrow</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">xrow</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Nfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nfft</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">xrow</span>

    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>

    <span class="n">tcol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">hlength</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">Nfft</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">hlength</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">hlength</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">hlength</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">hrow</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">hrow</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">Lh</span><span class="o">=</span><span class="p">(</span><span class="n">hrow</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">tfr</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nfft</span><span class="p">,</span><span class="n">tcol</span><span class="p">))</span>   
    <span class="k">for</span> <span class="n">icol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tcol</span><span class="p">):</span>
        <span class="n">ti</span><span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">icol</span><span class="p">];</span> 
        <span class="n">tau</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Nfft</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="n">Lh</span><span class="p">,</span><span class="n">ti</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Nfft</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="n">Lh</span><span class="p">,</span><span class="n">xrow</span><span class="o">-</span><span class="n">ti</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">Nfft</span><span class="o">+</span><span class="n">tau</span><span class="p">,</span><span class="n">Nfft</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">);</span> 
        <span class="n">tfr</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span><span class="n">icol</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">ti</span><span class="o">+</span><span class="n">tau</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">Lh</span><span class="o">+</span><span class="n">tau</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">Lh</span><span class="o">+</span><span class="n">tau</span><span class="p">])</span>
    
    <span class="n">tfr</span><span class="o">=</span><span class="n">fft</span><span class="p">(</span><span class="n">tfr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">tfr</span></div>

<div class="viewcode-block" id="get_istft"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.get_istft">[docs]</a><span class="k">def</span> <span class="nf">get_istft</span><span class="p">(</span><span class="n">tfr</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="n">N</span><span class="p">,</span><span class="n">NbPoints</span> <span class="o">=</span> <span class="n">tfr</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">tcol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">hrow</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> 
    <span class="n">Lh</span><span class="o">=</span><span class="p">(</span><span class="n">hrow</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
    <span class="n">tfr</span><span class="o">=</span><span class="n">ifft</span><span class="p">(</span><span class="n">tfr</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tcol</span><span class="p">,))</span>
    <span class="k">for</span> <span class="n">icol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tcol</span><span class="p">):</span>
        <span class="n">valuestj</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="n">icol</span><span class="o">-</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">icol</span><span class="o">-</span><span class="n">Lh</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">tcol</span><span class="p">,</span><span class="n">icol</span><span class="o">+</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">icol</span><span class="o">+</span><span class="n">Lh</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tj</span> <span class="ow">in</span> <span class="n">valuestj</span><span class="p">:</span>
            <span class="n">tau</span><span class="o">=</span><span class="n">icol</span><span class="o">-</span><span class="n">tj</span> 
            <span class="n">indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="n">tau</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span><span class="o">+</span><span class="n">tfr</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span><span class="n">tj</span><span class="p">]</span><span class="o">*</span><span class="n">window</span><span class="p">[</span><span class="n">Lh</span><span class="o">+</span><span class="n">tau</span><span class="p">]</span>
        
        <span class="n">x</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">Lh</span><span class="o">+</span><span class="n">icol</span><span class="o">-</span><span class="n">valuestj</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span></div>


<span class="c1"># def get_stft(signal, window = None, overlap = None):</span>
<span class="c1">#     &quot;&quot;&quot; Compute the STFT of the signal. Signal is padded with zeros.</span>
<span class="c1">#     The outputs corresponds to the STFT with the regular size and also the</span>
<span class="c1">#     zero padded version. The signal is zero padded to alleviate border effects.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         signal (ndarray): The signal to analyse.</span>
<span class="c1">#         window (ndarray, optional): The window to use. If None, uses a rounded Gaussian</span>
<span class="c1">#         window. Defaults to None.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         stft(ndarray): Returns de stft of the signal.</span>
<span class="c1">#         stft_padded(ndarray): Returns the stft of the zero-padded signal.</span>
<span class="c1">#         Npad(int): Number of zeros padded on each side of the signal.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
    
<span class="c1">#     N = np.max(signal.shape)</span>
<span class="c1">#     if window is None:</span>
<span class="c1">#         window, _ = get_round_window(N)</span>

<span class="c1">#     Npad = N//2 #0 #int(np.sqrt(N))</span>
<span class="c1">#     Nfft = len(window)</span>
    
<span class="c1">#     if overlap is None:</span>
<span class="c1">#         overlap = Nfft-1</span>
    
<span class="c1">#     if signal.dtype == complex128:</span>
<span class="c1">#         signal_pad = np.zeros(N+2*Npad, dtype=complex128)</span>
<span class="c1">#     else:</span>
<span class="c1">#         signal_pad = np.zeros(N+2*Npad)</span>

<span class="c1">#     # signal_pad = np.zeros(N+2*Npad)</span>
<span class="c1">#     signal_pad[Npad:Npad+N] = signal</span>

<span class="c1">#     # computing STFT</span>
<span class="c1">#     _, _, stft_padded = sg.stft(signal_pad, window=window, nperseg=Nfft, noverlap = overlap)</span>
    
<span class="c1">#     # if signal.dtype == complex128:</span>
<span class="c1">#     #     stft_padded = stft_padded[0:Nfft//2+1,:]</span>
        
<span class="c1">#     stft = stft_padded[:,Npad:Npad+N]</span>
<span class="c1">#     return stft, stft_padded, Npad</span>


<div class="viewcode-block" id="get_spectrogram"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.get_spectrogram">[docs]</a><span class="k">def</span> <span class="nf">get_spectrogram</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">Nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the round spectrogram of the signal computed with a given window. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        signal(ndarray): A vector with the signal to analyse.</span>

<span class="sd">    Returns:</span>
<span class="sd">        S(ndarray): Spectrogram of the signal.</span>
<span class="sd">        stft: Short-time Fourier transform of the signal.</span>
<span class="sd">        stft_padded: Short-time Fourier transform of the padded signal.</span>
<span class="sd">        Npad: Number of zeros added in the zero-padding process.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Nfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nfft</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span>

    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
        
    <span class="n">stft</span><span class="o">=</span><span class="n">get_stft</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">Nfft</span><span class="o">=</span><span class="n">Nfft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">onesided</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,:])</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>                
    <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">stft</span></div>


<div class="viewcode-block" id="find_zeros_of_spectrogram"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.find_zeros_of_spectrogram">[docs]</a><span class="k">def</span> <span class="nf">find_zeros_of_spectrogram</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="n">aux_S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">Inf</span>
    <span class="n">aux_S</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">aux_S</span>
    <span class="n">aux_ceros</span> <span class="o">=</span> <span class="p">((</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span> 
            <span class="p">)</span>
    <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_ceros</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># Position of zeros in norm. coords.</span>
    <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">pos</span></div>


<div class="viewcode-block" id="reconstruct_signal"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.reconstruct_signal">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_signal</span><span class="p">(</span><span class="n">hull_d</span><span class="p">,</span> <span class="n">stft</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruction using the convex hull.</span>
<span class="sd">    This function is deprecated and conserved for retrocompatibility purposes only.</span>

<span class="sd">    Args:</span>
<span class="sd">        hull_d (_type_): _description_</span>
<span class="sd">        stft (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Nfft</span> <span class="o">=</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))</span>
    <span class="n">tmax</span> <span class="o">=</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">tmin</span>
    <span class="n">fmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))</span>
    <span class="n">fmax</span> <span class="o">=</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">fmin</span>

    <span class="c1"># sub mask : check which points are in the convex hull</span>
    <span class="n">vecx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))))</span>
    <span class="n">vecy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">vecx</span><span class="p">,</span> <span class="n">vecy</span><span class="p">))</span>
    <span class="n">sub_mask</span> <span class="o">=</span> <span class="n">hull_d</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">0</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">fmin</span><span class="p">:</span><span class="n">fmax</span><span class="p">,</span> <span class="n">tmin</span><span class="p">:</span><span class="n">tmax</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_mask</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mascara:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="c1"># create a mask</span>
    <span class="c1">#mask = np.zeros(stft.shape, dtype=bool)</span>
    <span class="c1">#mask[fmin:fmax, base+tmin:base+tmax] = sub_mask</span>

    <span class="c1"># reconstruction</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">Nfft</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">/</span><span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1"># t, xorigin = sg.istft(stft, window=g,  nperseg=Nfft, noverlap=Nfft-1)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">xr</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">mask</span><span class="o">*</span><span class="n">stft</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>  <span class="n">nperseg</span><span class="o">=</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">Nfft</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">t</span> </div>



<div class="viewcode-block" id="reconstruct_signal_2"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.reconstruct_signal_2">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_signal_2</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">stft</span><span class="p">,</span> <span class="n">Npad</span><span class="p">,</span> <span class="n">Nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruction using a mask given as parameter</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (_type_): _description_</span>
<span class="sd">        stft (_type_): _description_</span>
<span class="sd">        Npad (_type_): _description_</span>
<span class="sd">        Nfft (_type_, optional): _description_. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Ni</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">Nfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nfft</span> <span class="o">=</span> <span class="n">Ni</span>
    
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">Nfft</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">window</span><span class="o">/</span><span class="n">window</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    
    <span class="n">Nfft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">overlap</span><span class="o">=</span><span class="n">Nfft</span><span class="o">-</span><span class="mi">1</span>


    <span class="c1"># reconstruction        </span>
    <span class="n">mask_aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">mask_aux</span><span class="p">[:,</span><span class="n">Npad</span><span class="p">:</span><span class="n">Npad</span><span class="o">+</span><span class="n">Ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
    <span class="c1"># t, xorigin = sg.istft(stft, window=g,  nperseg=Nfft, noverlap=Nfft-1)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">xr</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">mask_aux</span><span class="o">*</span><span class="n">stft</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">noverlap</span> <span class="o">=</span> <span class="n">overlap</span><span class="p">)</span>
    <span class="n">xr</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="n">Npad</span><span class="p">:</span><span class="n">Npad</span><span class="o">+</span><span class="n">Ni</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">xr</span><span class="p">,</span> <span class="n">t</span></div>

<div class="viewcode-block" id="reconstruct_signal_3"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.reconstruct_signal_3">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_signal_3</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">stft</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">mask_complete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">stft</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">mask_complete</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],:]</span> <span class="o">=</span> <span class="n">mask</span>
    <span class="n">mask_complete</span><span class="p">[</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]::,:]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="n">xr</span> <span class="o">=</span> <span class="n">get_istft</span><span class="p">(</span><span class="n">stft</span><span class="o">*</span><span class="n">mask_complete</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">xr</span></div>


<span class="c1"># def find_zeros_of_spectrogram(M,th=1e-14):</span>
<span class="c1">#     &quot;&quot;&quot; Finds the local minima of the spectrogram matrix M.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         M (_type_): Matrix with real values.</span>
<span class="c1">#         th (_type_): A given threshold.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         _type_: _description_</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     C,R = M.shape</span>
<span class="c1">#     Mid_Mid = np.zeros((C,R), dtype=bool)</span>
<span class="c1">#     for c in range(1, C-1):</span>
<span class="c1">#         for r in range(1, R-1):</span>
<span class="c1">#             T = M[c-1:c+2,r-1:r+2]</span>
<span class="c1">#             Mid_Mid[c, r] = (np.min(T) == T[1, 1]) * (np.min(T) &gt; th)</span>
<span class="c1">#             #Mid_Mid[c, r] = (np.min(T) == T[1, 1])</span>
<span class="c1">#     x, y = np.where(Mid_Mid)</span>
<span class="c1">#     pos = np.zeros((len(x), 2)) # Position of zeros in norm. coords.</span>
<span class="c1">#     pos[:, 0] = x</span>
<span class="c1">#     pos[:, 1] = y</span>
<span class="c1">#     return pos</span>


<div class="viewcode-block" id="snr_comparison"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.snr_comparison">[docs]</a><span class="k">def</span> <span class="nf">snr_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x_hat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Args:</span>
<span class="sd">        x (_type_): _description_</span>
<span class="sd">        x_hat (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">qrf</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x_hat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">qrf</span></div>


<div class="viewcode-block" id="add_snr_block"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.add_snr_block">[docs]</a><span class="k">def</span> <span class="nf">add_snr_block</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">snr</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds noise to a signal x with SNR equal to snr.</span>
<span class="sd">    SNR is defined as SNR (dB) = 10 * log10(Ex/En), where Ex and En are the energy of </span>
<span class="sd">    the signal and the noise, respectively.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (ndarray): Signal.</span>
<span class="sd">        snr (_type_): Signal-to-Noise Ratio in dB.</span>
<span class="sd">        K (int, optional): The number of noisy signals generated, vertically stacked. </span>
<span class="sd">        Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Block of shape [K,N], where K is the number of noisy signals, and N is </span>
<span class="sd">        length of the signal x.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># print(x)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">K</span><span class="p">)</span>
    <span class="c1"># n = n - np.mean(n,axis = 0)</span>
    <span class="c1"># print(np.mean(n, axis = 0))</span>
    <span class="c1"># x = x+n</span>

    <span class="n">Pn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>
    <span class="c1"># print(np.sum(n[:,0]**2))</span>

    <span class="n">Pn</span> <span class="o">=</span> <span class="n">Px</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span> <span class="n">snr</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>
    <span class="n">snr_out1</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
    <span class="n">snr_out</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Px</span> <span class="o">/</span> <span class="n">Pn</span><span class="p">)</span>
    <span class="c1"># print(snr_out)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">n</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">T</span></div>
    

<div class="viewcode-block" id="add_snr"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.add_snr">[docs]</a><span class="k">def</span> <span class="nf">add_snr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">snr</span><span class="p">,</span><span class="n">complex_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds noise to a signal x with SNR equal to snr. SNR is defined as </span>
<span class="sd">    SNR (dB) = 10 * log10(Ex/En), where Ex and En are the energy of the signal and the </span>
<span class="sd">    noise, respectively.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (ndarray): Signal.</span>
<span class="sd">        snr (_type_): Signal-to-Noise Ratio in dB.</span>
<span class="sd">        K (int, optional): The number of noisy signals generated, vertically stacked. </span>
<span class="sd">        Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Block of shape [K,N], where K is the number of noisy signals, and N is </span>
<span class="sd">        length of the signal x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Create the noise for signal with given SNR:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">complex_noise</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
        
    <span class="n">Pn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Normalize to 1 the variance of noise.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>
    <span class="n">Pn</span> <span class="o">=</span> <span class="n">Px</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span> <span class="n">snr</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># Give noise the prescribed variance.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>

    <span class="c1"># Pn = Px * 10 ** (- snr / 10)</span>
    <span class="c1"># n = n * np.sqrt(Pn)</span>
    <span class="c1"># snr_out1 = 20 * np.log10(np.sqrt(np.sum(x**2))/np.sqrt(np.sum(n**2)))</span>
    <span class="n">snr_out</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Px</span> <span class="o">/</span> <span class="n">Pn</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;snr_out:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">snr_out</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">n</span><span class="p">,</span><span class="n">n</span></div>


<div class="viewcode-block" id="hermite_poly"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.hermite_poly">[docs]</a><span class="k">def</span> <span class="nf">hermite_poly</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">return_all</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a Hermite polynomial of order n on the vector t.</span>

<span class="sd">    Args:</span>
<span class="sd">        t (ndarray, float): A real valued vector on which compute the Hermite </span>
<span class="sd">        polynomials.</span>
<span class="sd">        n (int): Order of the Hermite polynomial.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Returns an array with the Hermite polynomial computed on t.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">all_hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),))</span>
        <span class="n">all_hp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span>

    <span class="k">else</span><span class="p">:</span>
            <span class="n">hp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span>
            <span class="n">all_hp</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),))</span>
            <span class="n">all_hp</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">hp</span>
            <span class="c1"># if n &gt;= 1:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># hp = 2*t*hermite_poly(t,n-1) - 2*(n-1)*hermite_poly(t,n-2)</span>
                <span class="n">hp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">hp</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_all</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hp</span><span class="p">,</span> <span class="n">all_hp</span></div>


<div class="viewcode-block" id="hermite_fun"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.hermite_fun">[docs]</a><span class="k">def</span> <span class="nf">hermite_fun</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_all</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes an Hermite function of order q, that consist in a centered Hermite </span>
<span class="sd">    polynomial multiplied by the squared-root of a centered Gaussian given by: </span>
<span class="sd">    exp(-pi(t/T)^2). The parameter T fixes the width of the Gaussian function.</span>

<span class="sd">    Args:</span>
<span class="sd">        N (int): Length of the function in samples</span>
<span class="sd">        q (int): Order of the Hermite polynomial.</span>
<span class="sd">        t (ndarray): Values on which compute the function. If None, uses a centered </span>
<span class="sd">        vector from -N//2 to N//2-1. Defaults to None.</span>
<span class="sd">        T (float): Scale of the Gaussian involved in the Hermite function. If None,</span>
<span class="sd">        N = sqrt(N). Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span>

    <span class="k">if</span> <span class="n">T</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">all_hp</span> <span class="o">=</span> <span class="n">hermite_poly</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">T</span><span class="p">,</span> <span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">return_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">gaussian_basic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">T</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="n">hfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="n">Cnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)))</span>
        <span class="c1"># gaussian_basic /= np.sum(gaussian_basic)</span>
        <span class="n">hfunc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaussian_basic</span><span class="o">*</span><span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">Cnorm</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_all</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hfunc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hfunc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">hfunc</span></div>
        
<div class="viewcode-block" id="sigmerge"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.sigmerge">[docs]</a><span class="k">def</span> <span class="nf">sigmerge</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">return_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Get signal parameters.</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">ex1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ex2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">h</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ex1</span><span class="o">/</span><span class="p">(</span><span class="n">ex2</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">ratio</span><span class="o">/</span><span class="mi">10</span><span class="p">)))</span>
    <span class="n">scaled_noise</span> <span class="o">=</span> <span class="n">noise</span><span class="o">*</span><span class="n">h</span>
    <span class="n">sig</span><span class="o">=</span><span class="n">x1</span><span class="o">+</span><span class="n">scaled_noise</span>

    <span class="k">if</span> <span class="n">return_noise</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sig</span><span class="p">,</span> <span class="n">scaled_noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sig</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Juan Manuel Miramont-Taurel.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>