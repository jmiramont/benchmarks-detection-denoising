<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>benchmark_demo.spatstats_utils &mdash; Benchmarks of Multicomponent Signal Methods  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Benchmarks of Multicomponent Signal Methods
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">benchmark_demo</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Benchmarks of Multicomponent Signal Methods</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">benchmark_demo.spatstats_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for benchmark_demo.spatstats_utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">complex128</span><span class="p">,</span> <span class="n">dtype</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sg</span>
<span class="kn">import</span> <span class="nn">importlib.util</span> 
<span class="n">rpy2_is_present</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="s1">&#39;rpy2&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">rpy2_is_present</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">rpy2.robjects</span> <span class="k">as</span> <span class="nn">robjects</span>
    <span class="kn">from</span> <span class="nn">rpy2.robjects</span> <span class="kn">import</span> <span class="n">numpy2ri</span>
    <span class="kn">from</span> <span class="nn">rpy2.robjects.packages</span> <span class="kn">import</span> <span class="n">importr</span>
    <span class="kn">from</span> <span class="nn">spatstat_interface.interface</span> <span class="kn">import</span> <span class="n">SpatstatInterface</span>

<span class="kn">from</span> <span class="nn">benchmark_demo.utilstf</span> <span class="kn">import</span> <span class="n">find_zeros_of_spectrogram</span><span class="p">,</span> <span class="n">get_round_window</span><span class="p">,</span><span class="n">get_spectrogram</span><span class="p">,</span> <span class="n">get_stft</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">cumtrapz</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<div class="viewcode-block" id="compute_positions_and_bounds"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.compute_positions_and_bounds">[docs]</a><span class="k">def</span> <span class="nf">compute_positions_and_bounds</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the python vector of positions of points ```pos``` into a R object.</span>
<span class="sd">        Then, computes the bounds of the observation window for the computation of </span>
<span class="sd">        functional statistics. </span>

<span class="sd">        Args:</span>
<span class="sd">            pos (numpy.array): Array with the coordinates of each point in the plane.</span>

<span class="sd">        Returns:</span>
<span class="sd">            u_r (FloatVector): R float vector with horizontal coordinates of the points.</span>
<span class="sd">            v_r (FloatVector): R float vector with vertical coordinates of the points.</span>
<span class="sd">            bounds_u (numpy.array): Array with the horizontal bounds of the window.</span>
<span class="sd">            bounds_v (numpy.array): Array with the vertical bounds of the window.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">u_r</span> <span class="o">=</span> <span class="n">robjects</span><span class="o">.</span><span class="n">FloatVector</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>                       
        <span class="n">v_r</span> <span class="o">=</span> <span class="n">robjects</span><span class="o">.</span><span class="n">FloatVector</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">bounds_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])])</span>
        <span class="n">bounds_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])])</span>
        <span class="n">b_u</span> <span class="o">=</span> <span class="n">robjects</span><span class="o">.</span><span class="n">FloatVector</span><span class="p">(</span><span class="n">bounds_u</span><span class="p">)</span>        
        <span class="n">b_v</span> <span class="o">=</span> <span class="n">robjects</span><span class="o">.</span><span class="n">FloatVector</span><span class="p">(</span><span class="n">bounds_v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">u_r</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">b_u</span><span class="p">,</span> <span class="n">b_v</span></div>



<div class="viewcode-block" id="get_white_noise_zeros"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.get_white_noise_zeros">[docs]</a><span class="k">def</span> <span class="nf">get_white_noise_zeros</span><span class="p">(</span><span class="n">stft_params</span><span class="p">,</span> <span class="n">complex_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the zeros of the spectrogram of (real or complex) white Gaussian noise.</span>
<span class="sd">    If the noise generated is real, the zeros considered are those &quot;far&quot; from the time</span>
<span class="sd">    axis. (See Bardenet, Flamant and Chainais 2020 for details.)</span>

<span class="sd">    Args:</span>
<span class="sd">        stft_params (list or tuple): The length N of the noise and Nfft, the number of</span>
<span class="sd">                                    frequency bins of the short-time Fourier transform.</span>
<span class="sd">        complex_noise (bool, optional): Use complex noise or not. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A Nx2 array with the positions of the N zeros found. The first </span>
<span class="sd">                        column correspond to the y coordinate, the second to the x one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">Nfft</span> <span class="o">=</span> <span class="n">stft_params</span>
    <span class="n">wnoise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">complex_noise</span><span class="p">:</span>
        <span class="n">wnoise</span> <span class="o">=</span> <span class="n">wnoise</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">wnoise</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Computes the spectrogram and its zeros.</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>
    <span class="n">stft</span> <span class="o">=</span> <span class="n">get_stft</span><span class="p">(</span><span class="n">wnoise</span><span class="p">,</span> <span class="n">window</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">Nfft</span><span class="o">=</span><span class="n">Nfft</span><span class="p">)</span>
    <span class="n">stf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,:])</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># Find Spectrogram Zeros</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">find_zeros_of_spectrogram</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stf</span><span class="p">))</span>

    <span class="c1"># fig, ax = plt.subplots(1,1)</span>
    <span class="c1"># ax.imshow(-np.log10(abs(stf)), origin=&#39;lower&#39;)</span>
    <span class="c1"># ax.plot(pos[:,1],pos[:,0],&#39;w.&#39;)</span>
    <span class="c1"># plt.show()</span>

    <span class="c1"># Get only the zeros &quot;far&quot; from the real axis if the noise is real.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">complex_noise</span><span class="p">:</span>
        <span class="n">margin</span> <span class="o">=</span> <span class="n">T</span>
        <span class="n">valid_ceros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">valid_ceros</span><span class="p">[(</span><span class="n">margin</span><span class="o">&lt;</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="kc">True</span> 
        <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">valid_ceros</span><span class="p">]</span>

    <span class="c1"># fig, ax = plt.subplots(1,1)</span>
    <span class="c1"># ax.imshow(-np.log10(abs(stf)), origin=&#39;lower&#39;)</span>
    <span class="c1"># ax.plot(pos[:,1],pos[:,0],&#39;w.&#39;)</span>
    <span class="c1"># plt.show()</span>

    <span class="k">return</span> <span class="n">pos</span></div>


<div class="viewcode-block" id="ComputeStatistics"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.ComputeStatistics">[docs]</a><span class="k">class</span> <span class="nc">ComputeStatistics</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class that encapsulates the code for computing functional statistics.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spatstat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">spatstat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            
        <span class="c1"># print(&#39;Starting spatstat-interface...&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatstat</span> <span class="o">=</span> <span class="n">SpatstatInterface</span><span class="p">(</span><span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatstat</span> <span class="o">=</span> <span class="n">spatstat</span>
        
        <span class="c1">#self.spatstat.import_package(&quot;core&quot;, &quot;geom&quot;, update=False)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatstat</span><span class="o">.</span><span class="n">import_package</span><span class="p">(</span><span class="s2">&quot;explore&quot;</span><span class="p">,</span> <span class="s2">&quot;geom&quot;</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        

<div class="viewcode-block" id="ComputeStatistics.compute_Lest"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.ComputeStatistics.compute_Lest">[docs]</a>    <span class="k">def</span> <span class="nf">compute_Lest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">r_des</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute the functional statistic L, also referred as variance-normalized </span>
<span class="sd">        Ripley&#39;s K, for a point-process, the coordinates of the points given in ```pos```.</span>
<span class="sd">        L is computed for the radius given in ```r_des```.</span>

<span class="sd">        Args:</span>
<span class="sd">            pos (_type_): Positions of the points in the point-process realization.</span>
<span class="sd">            r_des (_type_): Desired radius to compute the L statistic.</span>

<span class="sd">        Returns:</span>
<span class="sd">            _type_: _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">radi</span> <span class="o">=</span> <span class="n">robjects</span><span class="o">.</span><span class="n">FloatVector</span><span class="p">(</span><span class="n">r_des</span><span class="p">)</span>                      
        <span class="n">u_r</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">b_u</span><span class="p">,</span> <span class="n">b_v</span> <span class="o">=</span> <span class="n">compute_positions_and_bounds</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">ppp_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatstat</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">ppp</span><span class="p">(</span><span class="n">u_r</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">b_u</span><span class="p">,</span> <span class="n">b_v</span><span class="p">)</span>
        <span class="n">numpy2ri</span><span class="o">.</span><span class="n">deactivate</span><span class="p">()</span>
        <span class="c1">#L_r = self.spatstat.core.Lest(ppp_r, r=radi)</span>
        <span class="n">L_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatstat</span><span class="o">.</span><span class="n">explore</span><span class="o">.</span><span class="n">Lest</span><span class="p">(</span><span class="n">ppp_r</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">radi</span><span class="p">)</span>  

        <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_r</span><span class="o">.</span><span class="n">rx2</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">))</span> 
        <span class="n">Lborder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_r</span><span class="o">.</span><span class="n">rx2</span><span class="p">(</span><span class="s1">&#39;border&#39;</span><span class="p">))</span>
        <span class="n">Ltrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_r</span><span class="o">.</span><span class="n">rx2</span><span class="p">(</span><span class="s1">&#39;trans&#39;</span><span class="p">))</span>
        <span class="n">Liso</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_r</span><span class="o">.</span><span class="n">rx2</span><span class="p">(</span><span class="s1">&#39;iso&#39;</span><span class="p">))</span>

        <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lborder</span><span class="p">,</span> <span class="n">Ltrans</span><span class="p">,</span> <span class="n">Liso</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">radius</span></div>


<div class="viewcode-block" id="ComputeStatistics.compute_Fest"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.ComputeStatistics.compute_Fest">[docs]</a>    <span class="k">def</span> <span class="nf">compute_Fest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">r_des</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">correction</span> <span class="o">=</span> <span class="s1">&#39;rs&#39;</span><span class="p">,</span> <span class="n">var_stb</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the functional statistic F, also referred as empty space function, </span>
<span class="sd">        for a point-process, the coordinates of the points given in ```pos```.</span>
<span class="sd">        F is computed for the radius given in ```r_des```.</span>
<span class="sd">        Args:</span>
<span class="sd">            pos (_type_): Positions of the points in the point-process realization.</span>
<span class="sd">            r_des (_type_, optional): Desired radius to compute the L statistic. </span>
<span class="sd">            Defaults to None.</span>
<span class="sd">            estimator_type (str, optional): _description_. Defaults to &#39;rs&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            _type_: _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">radius_r</span> <span class="o">=</span> <span class="n">robjects</span><span class="o">.</span><span class="n">FloatVector</span><span class="p">(</span><span class="n">r_des</span><span class="p">)</span>
        <span class="n">u_r</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">b_u</span><span class="p">,</span> <span class="n">b_v</span> <span class="o">=</span> <span class="n">compute_positions_and_bounds</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>        
        <span class="n">ppp_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatstat</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">ppp</span><span class="p">(</span><span class="n">u_r</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">b_u</span><span class="p">,</span> <span class="n">b_v</span><span class="p">)</span>
        <span class="n">numpy2ri</span><span class="o">.</span><span class="n">deactivate</span><span class="p">()</span>
        <span class="n">F_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatstat</span><span class="o">.</span><span class="n">explore</span><span class="o">.</span><span class="n">Fest</span><span class="p">(</span><span class="n">ppp_r</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">radius_r</span><span class="p">)</span> 
        
        <span class="c1"># F_r = self.spatstat.core.Fest(ppp_r) </span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">F_r</span><span class="o">.</span><span class="n">rx2</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">))</span> 
        <span class="n">Fborder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">F_r</span><span class="o">.</span><span class="n">rx2</span><span class="p">(</span><span class="n">correction</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">var_stb</span><span class="p">:</span>
            <span class="n">Fborder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Fborder</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Fborder</span><span class="p">,</span> <span class="n">radius</span></div></div>


<div class="viewcode-block" id="pairCorrPlanarGaf"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.pairCorrPlanarGaf">[docs]</a><span class="k">def</span> <span class="nf">pairCorrPlanarGaf</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Args:</span>
<span class="sd">        r (_type_): _description_</span>
<span class="sd">        L (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">4</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="n">L</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="n">den</span>

    <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">rho</span></div>


<div class="viewcode-block" id="Kfunction"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.Kfunction">[docs]</a><span class="k">def</span> <span class="nf">Kfunction</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Args:</span>
<span class="sd">        r (_type_): _description_</span>
<span class="sd">        rho (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span>
    <span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">cumtrapz</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">rho</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">K</span></div>


<div class="viewcode-block" id="ginibreGaf"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.ginibreGaf">[docs]</a><span class="k">def</span> <span class="nf">ginibreGaf</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Args:</span>
<span class="sd">        r (_type_): _description_</span>
<span class="sd">        c (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rho</span></div>


<div class="viewcode-block" id="compute_S0"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.compute_S0">[docs]</a><span class="k">def</span> <span class="nf">compute_S0</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">Sexp</span><span class="p">,</span> <span class="n">statistic</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Sm</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Args:</span>
<span class="sd">        radius (_type_): _description_</span>
<span class="sd">        statistic (_type_, optional): _description_. Defaults to None.</span>
<span class="sd">        Sm (_type_, optional): _description_. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">statistic</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
        <span class="c1"># compute true GAF Lfunc</span>
        <span class="n">rho_gaf</span> <span class="o">=</span> <span class="n">pairCorrPlanarGaf</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">Krho_gaf</span> <span class="o">=</span> <span class="n">Kfunction</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">rho_gaf</span><span class="p">)</span>
        <span class="n">Lrho_gaf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Krho_gaf</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>   <span class="c1"># El valor te√≥rico que necesita para comparar.</span>
        <span class="k">return</span> <span class="n">Lrho_gaf</span>

    <span class="k">if</span> <span class="n">statistic</span> <span class="o">!=</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Sm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Smean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Sm</span><span class="p">,</span><span class="n">Sexp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Sexp</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Smean</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="compute_T_statistic"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.compute_T_statistic">[docs]</a><span class="k">def</span> <span class="nf">compute_T_statistic</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">Sm</span><span class="p">,</span> <span class="n">S0</span><span class="p">,</span> <span class="n">pnorm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">one_sided</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the T sumary statistic using the norm given as an argument.</span>

<span class="sd">    Args:</span>
<span class="sd">        radius (_type_): _description_</span>
<span class="sd">        rmax (_type_): _description_</span>
<span class="sd">        Sm (_type_): _description_</span>
<span class="sd">        S0 (_type_): _description_</span>
<span class="sd">        pnorm (int, optional): _description_. Defaults to 2.</span>
<span class="sd">        rmin (float, optional): _description_. Defaults to 0.0.</span>
<span class="sd">        one_sided (bool, optional): _description_. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sm</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Sm</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">Sm</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="n">S0</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">S0</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
    <span class="c1"># t2 = np.sqrt(np.cumsum((Sm-S0)**2, axis=1))      </span>
    <span class="c1"># tm = np.zeros_like(Sm)</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Sm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmax</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rmax</span><span class="p">)):</span>
        <span class="n">int_lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rmin</span><span class="o">&lt;=</span><span class="n">radius</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>    
        <span class="n">int_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rmax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">radius</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>


        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Sm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">int_ub</span><span class="o">&lt;</span><span class="n">int_lb</span><span class="p">:</span>
                <span class="n">tm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">difS</span> <span class="o">=</span> <span class="p">(</span><span class="n">S0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">int_lb</span><span class="p">:</span><span class="n">int_ub</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Sm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">int_lb</span><span class="p">:</span><span class="n">int_ub</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">one_sided</span><span class="p">:</span>
                    <span class="n">difS</span> <span class="o">=</span> <span class="n">difS</span><span class="p">[</span><span class="n">difS</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">tm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">difS</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">pnorm</span><span class="p">)</span>

                <span class="c1"># Use the squared 2-norm if this is the case.</span>
                <span class="k">if</span> <span class="n">pnorm</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">tm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">return</span> <span class="n">tm</span></div>


<div class="viewcode-block" id="compute_statistics"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.compute_statistics">[docs]</a><span class="k">def</span> <span class="nf">compute_statistics</span><span class="p">(</span><span class="n">sts</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">simulation_pos</span><span class="p">,</span> <span class="n">pos_exp</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">pnorm</span><span class="p">,</span> <span class="n">one_sided</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute the given functional statistics.</span>

<span class="sd">    Args:</span>
<span class="sd">        sts (_type_): _description_</span>
<span class="sd">        cs (_type_): _description_</span>
<span class="sd">        simulation_pos (_type_): _description_</span>
<span class="sd">        pos_exp (_type_): _description_</span>
<span class="sd">        radius (_type_): _description_</span>
<span class="sd">        rmax (_type_): _description_</span>
<span class="sd">        pnorm (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">MC_reps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">simulation_pos</span><span class="p">)</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">MC_reps</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmax</span><span class="p">)))</span>
    <span class="n">Sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">MC_reps</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">radius</span><span class="p">)))</span>

    <span class="c1"># A dictionary with the functions to compute the statistics.</span>
    <span class="k">if</span> <span class="n">cs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">ComputeStatistics</span><span class="p">()</span>

    <span class="n">stats_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">stats_dict</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">compute_Lest</span>
    <span class="n">stats_dict</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">compute_Fest</span>
    <span class="n">stats_dict</span><span class="p">[</span><span class="s1">&#39;Frs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="n">cs</span><span class="o">.</span><span class="n">compute_Fest</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;rs&#39;</span><span class="p">)</span>
    <span class="n">stats_dict</span><span class="p">[</span><span class="s1">&#39;Frs_vs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="n">cs</span><span class="o">.</span><span class="n">compute_Fest</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;rs&#39;</span><span class="p">,</span> <span class="n">var_stb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">stats_dict</span><span class="p">[</span><span class="s1">&#39;Fkm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="n">cs</span><span class="o">.</span><span class="n">compute_Fest</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;km&#39;</span><span class="p">)</span>
    <span class="n">stats_dict</span><span class="p">[</span><span class="s1">&#39;Fkm_vs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="n">cs</span><span class="o">.</span><span class="n">compute_Fest</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;km&#39;</span><span class="p">,</span> <span class="n">var_stb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">stats_dict</span><span class="p">[</span><span class="s1">&#39;Fcs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="n">cs</span><span class="o">.</span><span class="n">compute_Fest</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;cs&#39;</span><span class="p">)</span>

    <span class="c1"># Compute empirical S.</span>
    <span class="n">Sexp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stats_dict</span><span class="p">[</span><span class="n">sts</span><span class="p">](</span><span class="n">pos_exp</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>

    <span class="c1"># Compute the statistic Sm for the m-th realization of noise.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">simulation_pos</span><span class="p">):</span>
        <span class="n">Sm</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stats_dict</span><span class="p">[</span><span class="n">sts</span><span class="p">](</span><span class="n">pos</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span> 

    <span class="n">S0</span> <span class="o">=</span> <span class="n">compute_S0</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">Sexp</span><span class="p">,</span> <span class="n">statistic</span> <span class="o">=</span> <span class="n">sts</span><span class="p">,</span> <span class="n">Sm</span><span class="o">=</span><span class="n">Sm</span><span class="p">)</span>
    <span class="c1"># Compute the T statistic as T= Sm-S_0 where S_0 is the theoretic or average value.</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">compute_T_statistic</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">Sm</span><span class="p">,</span> <span class="n">S0</span><span class="p">,</span> <span class="n">pnorm</span><span class="o">=</span><span class="n">pnorm</span><span class="p">,</span><span class="n">one_sided</span><span class="o">=</span><span class="n">one_sided</span><span class="p">)</span>
    <span class="c1"># sort values of t for null hypothesis</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="c1"># Compute empirical statistic texp</span>
    <span class="n">t_exp</span> <span class="o">=</span> <span class="n">compute_T_statistic</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">Sexp</span><span class="p">,</span> <span class="n">S0</span><span class="p">,</span> <span class="n">pnorm</span><span class="o">=</span><span class="n">pnorm</span><span class="p">,</span><span class="n">one_sided</span><span class="o">=</span><span class="n">one_sided</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tm</span><span class="p">,</span> <span class="n">t_exp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">Sm</span><span class="p">,</span> <span class="n">Sexp</span><span class="p">,</span> <span class="n">S0</span></div>


<div class="viewcode-block" id="compute_monte_carlo_sims"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.compute_monte_carlo_sims">[docs]</a><span class="k">def</span> <span class="nf">compute_monte_carlo_sims</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span>
                    <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">Nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">MC_reps</span> <span class="o">=</span> <span class="mi">199</span><span class="p">,</span>
                    <span class="n">statistic</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">,</span>
                    <span class="n">pnorm</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="n">radius</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">rmax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">one_sided</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the Monte Carlo simulations.</span>

<span class="sd">    Args:</span>
<span class="sd">        signal (_type_): _description_</span>
<span class="sd">        cs (_type_, optional): _description_. Defaults to None.</span>
<span class="sd">        Nfft (_type_, optional): _description_. Defaults to None.</span>
<span class="sd">        MC_reps (int, optional): _description_. Defaults to 199.</span>
<span class="sd">        statistic (str, optional): _description_. Defaults to &#39;L&#39;.</span>
<span class="sd">        pnorm (int, optional): _description_. Defaults to 2.</span>
<span class="sd">        radius (_type_, optional): _description_. Defaults to None.</span>
<span class="sd">        rmax (_type_, optional): _description_. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># rmax*(base)/np.sqrt(2*base) Use this for rmax in samples!</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Nfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nfft</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span>
        
    <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># radius = np.linspace(0, 4.0, 50)</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rmax</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
        <span class="n">rmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">rmax</span><span class="p">,)</span>

    <span class="k">if</span> <span class="n">rmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rmax</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="c1"># Computes the spectrogram and its zeros.</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>
    <span class="n">stft</span> <span class="o">=</span> <span class="n">get_stft</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">window</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">Nfft</span><span class="o">=</span><span class="n">Nfft</span><span class="p">)</span>
    <span class="n">stf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,:])</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># Find zeros of the spectrogram</span>
    <span class="n">pos_exp</span> <span class="o">=</span> <span class="n">find_zeros_of_spectrogram</span><span class="p">(</span><span class="n">stf</span><span class="p">)</span>

    <span class="c1"># If signal is real, do not take zeros near the time axis</span>
    <span class="k">if</span> <span class="n">signal</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">complex128</span><span class="p">:</span>
        <span class="n">complex_signal</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>  
        <span class="n">complex_signal</span><span class="o">=</span><span class="kc">False</span>
        <span class="n">valid_zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pos_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">valid_zeros</span><span class="p">[(</span><span class="n">T</span><span class="o">&lt;</span><span class="n">pos_exp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])]</span><span class="o">=</span><span class="kc">True</span> 
        <span class="n">pos_exp</span> <span class="o">=</span> <span class="n">pos_exp</span><span class="p">[</span><span class="n">valid_zeros</span><span class="p">]</span>

    <span class="n">pos_exp</span> <span class="o">/=</span> <span class="n">T</span>
    <span class="c1"># Compute noise distribution of zeros.</span>
    <span class="n">simulation_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># start = time.time() </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MC_reps</span><span class="p">):</span>   
        <span class="n">pos</span> <span class="o">=</span> <span class="n">get_white_noise_zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="n">Nfft</span><span class="p">],</span><span class="n">complex_noise</span><span class="o">=</span><span class="n">complex_signal</span><span class="p">)</span>
        <span class="n">pos</span><span class="o">/=</span><span class="n">T</span>     
        <span class="n">simulation_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    <span class="c1"># end = time.time()</span>
    <span class="c1"># print(end-start)</span>
    
    <span class="n">output</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">sts</span> <span class="ow">in</span> <span class="n">statistic</span><span class="p">:</span>
        <span class="n">tm</span><span class="p">,</span> <span class="n">t_exp</span><span class="p">,</span> <span class="n">Sm</span><span class="p">,</span> <span class="n">Sexp</span><span class="p">,</span> <span class="n">S0</span> <span class="o">=</span> <span class="n">compute_statistics</span><span class="p">(</span><span class="n">sts</span><span class="p">,</span>
                                                    <span class="n">cs</span><span class="p">,</span>
                                                    <span class="n">simulation_pos</span><span class="p">,</span>
                                                    <span class="n">pos_exp</span><span class="p">,</span>
                                                    <span class="n">radius</span><span class="p">,</span>
                                                    <span class="n">rmax</span><span class="p">,</span>
                                                    <span class="n">pnorm</span><span class="p">,</span>
                                                    <span class="n">one_sided</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="n">sts</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tm</span><span class="p">,</span><span class="n">t_exp</span><span class="p">,</span> <span class="n">Sm</span><span class="p">,</span> <span class="n">Sexp</span><span class="p">,</span> <span class="n">S0</span><span class="p">)</span>
   
    <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">radius</span></div>


<div class="viewcode-block" id="compute_envelope_test"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.compute_envelope_test">[docs]</a><span class="k">def</span> <span class="nf">compute_envelope_test</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> 
                    <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">MC_reps</span> <span class="o">=</span> <span class="mi">199</span><span class="p">,</span> 
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> 
                    <span class="n">statistic</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">,</span>
                    <span class="n">pnorm</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> 
                    <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">rmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">one_sided</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">return_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute hypothesis tests based on Monte Carlo simulations.</span>

<span class="sd">    Args:</span>
<span class="sd">        signal (ndarray): Numpy ndarray with the signal.</span>
<span class="sd">        cs (ComputeStatistics, optional): This is an object of the ComputeStatistics</span>
<span class="sd">        class, that encapsulates the initialization of the spatstat-interface python</span>
<span class="sd">        package. This allows avoiding reinitialize the interface each time. </span>
<span class="sd">        Defaults to None.</span>
<span class="sd">        MC_reps (int, optional): Repetitions of the Monte Carlo simulations. </span>
<span class="sd">        Defaults to 199.</span>
<span class="sd">        alpha (float, optional): Significance of the tests. Defaults to 0.05.</span>
<span class="sd">        statistic (str, optional): Functional statistic computed on the point process </span>
<span class="sd">        determined by the zeros of spectrogram of the signal. Defaults to &#39;L&#39;.</span>
<span class="sd">        pnorm (int, optional): Summary statistics for the envelope-tests. Common values </span>
<span class="sd">        for this parameter are &quot;np.inf&quot; for the supremum norm, or &quot;2&quot; for the usual 2 </span>
<span class="sd">        norm. Defaults to 2.</span>
<span class="sd">        radius (float, optional): Vector of radius used for the computation of the </span>
<span class="sd">        functional statistics. Defaults to None.</span>
<span class="sd">        rmax (float, optional): Maximum radius to compute the test. One test per value </span>
<span class="sd">        in rmax is compute. If it is None, the values given in &quot;radius&quot; are used. </span>
<span class="sd">        Defaults to None.</span>
<span class="sd">        return_values (bool, optional): If False, returns a dictionary with the </span>
<span class="sd">        results of the test for each statistic and value of rmax. If True, also returns </span>
<span class="sd">        the empirical statistic and the simulated statistics. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Returns a dictionary with the results. If more than one statistic is </span>
<span class="sd">        given as input parameter, the dictionary will have one entry per statistic.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">Nfft</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">MC_reps</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="c1"># corresponding k value</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">statistic</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">statistic</span> <span class="o">=</span> <span class="p">(</span><span class="n">statistic</span><span class="p">,)</span>

    <span class="n">output_dict</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">compute_monte_carlo_sims</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span>
                                        <span class="n">cs</span><span class="p">,</span>
                                        <span class="n">Nfft</span><span class="p">,</span>
                                        <span class="n">MC_reps</span><span class="o">=</span><span class="n">MC_reps</span><span class="p">,</span>
                                        <span class="n">statistic</span><span class="o">=</span><span class="n">statistic</span><span class="p">,</span>
                                        <span class="n">pnorm</span><span class="o">=</span><span class="n">pnorm</span><span class="p">,</span>
                                        <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
                                        <span class="n">rmax</span><span class="o">=</span><span class="n">rmax</span><span class="p">,</span>
                                        <span class="n">one_sided</span><span class="o">=</span><span class="n">one_sided</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">sts</span> <span class="ow">in</span> <span class="n">statistic</span><span class="p">:</span>
        <span class="n">tm</span><span class="p">,</span> <span class="n">t_exp</span><span class="p">,</span> <span class="n">Sm</span><span class="p">,</span> <span class="n">Sexp</span><span class="p">,</span> <span class="n">S0</span> <span class="o">=</span> <span class="n">output_dict</span><span class="p">[</span><span class="n">sts</span><span class="p">]</span>
        <span class="n">reject_H0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">reject_H0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t_exp</span> <span class="o">&gt;</span> <span class="n">tm</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">reject_H0</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">reject_H0</span> <span class="o">=</span> <span class="n">reject_H0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_values</span><span class="p">:</span>
            <span class="n">output_dict</span><span class="p">[</span><span class="n">sts</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;reject_H0&#39;</span><span class="p">:</span> <span class="n">reject_H0</span><span class="p">,</span>
                                <span class="s1">&#39;tm&#39;</span><span class="p">:</span> <span class="n">tm</span><span class="p">,</span>
                                <span class="s1">&#39;t_exp&#39;</span><span class="p">:</span> <span class="n">t_exp</span><span class="p">,</span>
                                <span class="s1">&#39;Sm&#39;</span><span class="p">:</span><span class="n">Sm</span><span class="p">,</span>
                                <span class="s1">&#39;Sexp&#39;</span><span class="p">:</span><span class="n">Sexp</span><span class="p">,</span> 
                                <span class="s1">&#39;S0&#39;</span><span class="p">:</span><span class="n">S0</span><span class="p">,</span>
                                <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
                                <span class="s1">&#39;radius&#39;</span><span class="p">:</span><span class="n">radius</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_dict</span><span class="p">[</span><span class="n">sts</span><span class="p">]</span> <span class="o">=</span> <span class="n">reject_H0</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">statistic</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>    
        <span class="k">return</span> <span class="n">output_dict</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c1"># returns (tm, t_exp) if only one statistic was computed.</span>
        <span class="k">return</span> <span class="n">output_dict</span><span class="p">[</span><span class="n">statistic</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> </div>


<div class="viewcode-block" id="generate_white_noise_zeros_pp"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.generate_white_noise_zeros_pp">[docs]</a><span class="k">def</span> <span class="nf">generate_white_noise_zeros_pp</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">nsim</span><span class="p">,</span> <span class="n">complex_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># STFT parameters.</span>
    <span class="n">Nfft</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>

    <span class="c1"># R packages.</span>
    <span class="n">rbase</span> <span class="o">=</span> <span class="n">importr</span><span class="p">(</span><span class="s1">&#39;base&#39;</span><span class="p">)</span>
    <span class="n">spatstat</span> <span class="o">=</span> <span class="n">SpatstatInterface</span><span class="p">(</span><span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">spatstat</span><span class="o">.</span><span class="n">import_package</span><span class="p">(</span><span class="s2">&quot;geom&quot;</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">parallel_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">N</span><span class="p">,</span><span class="n">Nfft</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsim</span><span class="p">)]</span>

    <span class="n">white_noise_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">params</span><span class="p">:</span> <span class="n">get_white_noise_zeros</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> 
                                                        <span class="n">complex_noise</span><span class="o">=</span><span class="n">complex_noise</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">nprocesses</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">nprocesses</span><span class="p">)</span> 
        <span class="n">list_of_zeros</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">white_noise_func</span><span class="p">,</span> <span class="n">parallel_list</span><span class="p">)</span> 
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> 
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_of_zeros</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">white_noise_func</span><span class="p">,</span><span class="n">parallel_list</span><span class="p">)</span> 

    <span class="n">list_ppp</span> <span class="o">=</span> <span class="n">rbase</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">list_of_zeros</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="o">/</span><span class="n">T</span>
        <span class="n">u_r</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">b_u</span><span class="p">,</span> <span class="n">b_v</span> <span class="o">=</span> <span class="n">compute_positions_and_bounds</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">ppp_noise</span> <span class="o">=</span> <span class="n">spatstat</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">ppp</span><span class="p">(</span><span class="n">u_r</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">b_u</span><span class="p">,</span> <span class="n">b_v</span><span class="p">)</span>
        <span class="c1"># ppp_noise = spatstat.geom.ppp(u_r, v_r)</span>
        
        <span class="n">list_ppp</span> <span class="o">=</span> <span class="n">rbase</span><span class="o">.</span><span class="n">c</span><span class="p">(</span><span class="n">list_ppp</span><span class="p">,</span> <span class="n">spatstat</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">as_solist</span><span class="p">(</span><span class="n">ppp_noise</span><span class="p">))</span>

    <span class="n">list_ppp</span> <span class="o">=</span> <span class="n">spatstat</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">as_solist</span><span class="p">(</span><span class="n">list_ppp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">list_ppp</span></div>
    

<div class="viewcode-block" id="compute_rank_envelope_test"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.compute_rank_envelope_test">[docs]</a><span class="k">def</span> <span class="nf">compute_rank_envelope_test</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span>
                                <span class="n">fun</span><span class="o">=</span><span class="s1">&#39;Fest&#39;</span><span class="p">,</span>
                                <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                                <span class="n">nsim</span><span class="o">=</span><span class="mi">2499</span><span class="p">,</span>
                                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                                <span class="n">rmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
                                <span class="n">rmax</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
                                <span class="n">ptype</span> <span class="o">=</span> <span class="s1">&#39;conservative&#39;</span><span class="p">,</span>
                                <span class="n">ppp_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">return_dic</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute a ranked envelopes test.</span>

<span class="sd">    Args:</span>
<span class="sd">        signal (_type_): _description_</span>
<span class="sd">        fun (str, optional): _description_. Defaults to &#39;Fest&#39;.</span>
<span class="sd">        correction (str, optional): _description_. Defaults to &#39;none&#39;.</span>
<span class="sd">        nsim (int, optional): _description_. Defaults to 2499.</span>
<span class="sd">        alpha (float, optional): _description_. Defaults to 0.05.</span>
<span class="sd">        rmin (float, optional): _description_. Defaults to 0.0.</span>
<span class="sd">        rmax (float, optional): _description_. Defaults to 1.2.</span>
<span class="sd">        ptype (str, optional): _description_. Defaults to &#39;conservative&#39;.</span>
<span class="sd">        ppp_sim (_type_, optional): _description_. Defaults to None.</span>
<span class="sd">        return_dic (bool, optional): _description_. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Initialize interface with R.</span>
    <span class="n">spatstat</span> <span class="o">=</span> <span class="n">SpatstatInterface</span><span class="p">(</span><span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1">#! &quot;explore&quot; instead of &quot;core&quot; for the new version of spatstat.</span>
    <span class="n">spatstat</span><span class="o">.</span><span class="n">import_package</span><span class="p">(</span><span class="s2">&quot;explore&quot;</span><span class="p">,</span> <span class="s2">&quot;geom&quot;</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># spatstat_random = importr(&#39;spatstat.random&#39;)</span>
    <span class="n">rbase</span> <span class="o">=</span> <span class="n">importr</span><span class="p">(</span><span class="s1">&#39;base&#39;</span><span class="p">)</span>
    <span class="n">package_GET</span> <span class="o">=</span> <span class="n">importr</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">)</span>
    
    <span class="c1"># STFT parameters.</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">Nfft</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">Nfft</span><span class="p">)</span>

    <span class="c1"># Generate empirical point-process:</span>
    <span class="n">signal_aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nfft</span><span class="p">,))</span>
    <span class="n">signal_aux</span><span class="p">[</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">4</span><span class="p">:</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">4</span><span class="o">+</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">signal_aux</span><span class="p">[</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">4</span><span class="p">:</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">4</span><span class="o">+</span><span class="n">N</span><span class="p">]</span>  <span class="o">=</span> <span class="n">signal</span>

    <span class="n">g</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>
    <span class="n">stft</span> <span class="o">=</span> <span class="n">get_stft</span><span class="p">(</span><span class="n">signal_aux</span><span class="p">,</span> <span class="n">window</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">Nfft</span><span class="o">=</span><span class="n">Nfft</span><span class="p">)</span>
    
    <span class="c1"># Computes the spectrogram and its zeros.</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">4</span><span class="p">:</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">4</span><span class="o">+</span><span class="n">N</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">find_zeros_of_spectrogram</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="c1"># If signal is real, do not take zeros near the time axis</span>
    <span class="k">if</span> <span class="n">signal</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">complex128</span><span class="p">:</span>
        <span class="n">complex_signal</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>  
        <span class="n">complex_signal</span><span class="o">=</span><span class="kc">False</span>
        <span class="n">valid_zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">valid_zeros</span><span class="p">[(</span><span class="n">T</span><span class="o">&lt;</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])]</span><span class="o">=</span><span class="kc">True</span> 
        <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">valid_zeros</span><span class="p">]</span>

    <span class="c1"># fig, ax = plt.subplots(1,1,figsize = (5,5))</span>
    <span class="c1"># ax.imshow(np.log10(abs(stft)), origin=&#39;lower&#39;)</span>
    <span class="c1"># ax.plot(pos[:,1],pos[:,0],&#39;w+&#39;)</span>
    <span class="c1"># plt.show()</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="o">/</span><span class="n">T</span>
    <span class="n">u_r</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">b_u</span><span class="p">,</span> <span class="n">b_v</span> <span class="o">=</span> <span class="n">compute_positions_and_bounds</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    <span class="n">ppp_r</span> <span class="o">=</span> <span class="n">spatstat</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">ppp</span><span class="p">(</span><span class="n">u_r</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">b_u</span><span class="p">,</span> <span class="n">b_v</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ppp_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ppp_sim</span> <span class="o">=</span> <span class="n">generate_white_noise_zeros_pp</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">nsim</span><span class="p">,</span><span class="n">complex_noise</span><span class="o">=</span><span class="n">complex_signal</span><span class="p">)</span>

    
    <span class="c1"># If a transform is passed as an extra (optional) parameter, apply first the</span>
    <span class="c1"># expression parsing function from R.</span>
    <span class="n">extra_args</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># Better copying before modifying input parameters.</span>
    <span class="k">if</span> <span class="s1">&#39;transform&#39;</span> <span class="ow">in</span> <span class="n">extra_args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">extra_args</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rbase</span><span class="o">.</span><span class="n">expression</span><span class="p">(</span><span class="n">extra_args</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">])</span>

    <span class="c1"># Compute simulated envelopes:</span>
    <span class="n">envelopes</span> <span class="o">=</span> <span class="n">spatstat</span><span class="o">.</span><span class="n">explore</span><span class="o">.</span><span class="n">envelope</span><span class="p">(</span><span class="n">ppp_r</span><span class="p">,</span> 
                                    <span class="n">fun</span><span class="o">=</span><span class="n">fun</span><span class="p">,</span> 
                                    <span class="n">nsim</span><span class="o">=</span><span class="n">nsim</span><span class="p">,</span> 
                                    <span class="n">savefuns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">correction</span><span class="o">=</span><span class="n">correction</span><span class="p">,</span> 
                                    <span class="n">simulate</span><span class="o">=</span><span class="n">ppp_sim</span><span class="p">,</span> 
                                    <span class="n">verbose</span><span class="o">=</span><span class="s1">&#39;FALSE&#39;</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">extra_args</span><span class="p">)</span>
    
    <span class="c1"># Crop envelopes if required.</span>
    <span class="n">envelopes</span> <span class="o">=</span> <span class="n">package_GET</span><span class="o">.</span><span class="n">crop_curves</span><span class="p">(</span><span class="n">envelopes</span><span class="p">,</span> <span class="n">r_min</span><span class="o">=</span><span class="n">rmin</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="n">rmax</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">envelopes</span><span class="p">)</span>

    <span class="c1"># Compute the actual test now.</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">package_GET</span><span class="o">.</span><span class="n">global_envelope_test</span><span class="p">(</span><span class="n">envelopes</span><span class="p">,</span> 
                                            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> 
                                            <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;rank&#39;</span><span class="p">,</span> 
                                            <span class="n">alternative</span> <span class="o">=</span> <span class="s1">&#39;less&#39;</span><span class="p">,</span> <span class="c1"># &lt;- We are doing</span>
                                            <span class="p">)</span>                       <span class="c1"># one-sided tests.  </span>
                                                                  

    <span class="c1"># Get the attributes from the results of the test.</span>
    <span class="n">res_attr</span> <span class="o">=</span> <span class="n">rbase</span><span class="o">.</span><span class="n">attributes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="c1"># Get p-value interval: Liberal (first index) and Conservative (second index).</span>
    <span class="n">numpy2ri</span><span class="o">.</span><span class="n">activate</span><span class="p">()</span>
    <span class="n">pval_int</span> <span class="o">=</span> <span class="n">res_attr</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s1">&#39;conservative&#39;</span><span class="p">:</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="n">pval_int</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ptype</span> <span class="o">==</span> <span class="s1">&#39;liberal&#39;</span><span class="p">:</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="n">pval_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Get envelopes and r.</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">obs</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">central</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

    <span class="c1"># fix, ax = plt.subplots(1,1)</span>
    <span class="c1"># ax.fill_between(r, lo, hi, color=&#39;g&#39;, alpha=.8)</span>
    <span class="c1"># ax.plot(r,obs,&#39;r--&#39;)</span>
    <span class="c1"># plt.show()</span>

    <span class="c1"># Check rejection of H0:</span>
    <span class="k">if</span> <span class="n">pval</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">:</span>
        <span class="n">rejectH0</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rejectH0</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># If rejected, compute the maximum distance between the empirical statistic and the</span>
    <span class="c1"># envelopes (it might be useful as an approximate scale of interaction).</span>
    <span class="n">r_max_dif</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ind_max_dif</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">rejectH0</span><span class="p">:</span>
        <span class="n">ind_max_dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">lo</span><span class="o">-</span><span class="n">obs</span><span class="p">)</span>
        <span class="n">r_max_dif</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">ind_max_dif</span><span class="p">]</span>

    <span class="c1"># Generate output dictionary:</span>
    <span class="k">if</span> <span class="n">return_dic</span><span class="p">:</span>
        <span class="n">output_dic</span> <span class="o">=</span> <span class="p">{</span>  <span class="s1">&#39;rejectH0&#39;</span><span class="p">:</span><span class="n">rejectH0</span><span class="p">,</span>
                    <span class="s1">&#39;envelope_obs&#39;</span><span class="p">:</span> <span class="n">obs</span><span class="p">,</span>
                    <span class="s1">&#39;envelope_lo&#39;</span><span class="p">:</span> <span class="n">lo</span><span class="p">,</span>
                    <span class="s1">&#39;envelope_hi&#39;</span><span class="p">:</span> <span class="n">hi</span><span class="p">,</span>
                    <span class="s1">&#39;envelope_central&#39;</span><span class="p">:</span><span class="n">central</span><span class="p">,</span>
                    <span class="s1">&#39;radi&#39;</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span>
                    <span class="s1">&#39;r_max_dif&#39;</span><span class="p">:</span> <span class="n">r_max_dif</span><span class="p">,</span>
                    <span class="s1">&#39;ind_max_dif&#39;</span><span class="p">:</span> <span class="n">ind_max_dif</span>
                <span class="p">}</span>
    
        <span class="k">return</span> <span class="n">output_dic</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rejectH0</span></div>


<div class="viewcode-block" id="compute_scale"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.compute_scale">[docs]</a><span class="k">def</span> <span class="nf">compute_scale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="o">**</span><span class="n">test_params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Args:</span>
<span class="sd">        signal (_type_): _description_</span>
<span class="sd">        Nfft (_type_): _description_</span>
<span class="sd">        cs (_type_, optional): _description_. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># If the simulated ppp are present, use them, otherwise, generate the simulation and</span>
    <span class="c1"># save it so that it can be used later (this saves time, avoiding re-simulation).</span>
    <span class="n">nsim</span> <span class="o">=</span> <span class="mi">2499</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;ppp_simulations_N_</span><span class="si">{}</span><span class="s1">_Nsim_</span><span class="si">{}</span><span class="s1">.mcsim&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">nsim</span><span class="p">),</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
            <span class="n">ppp_simulation</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;MC Simulation running...&#39;</span><span class="p">)</span>
        <span class="n">list_ppp</span> <span class="o">=</span> <span class="n">generate_white_noise_zeros_pp</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">nsim</span><span class="o">=</span><span class="n">nsim</span><span class="p">)</span>
        <span class="n">ppp_simulation</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;list_ppp&#39;</span><span class="p">:</span><span class="n">list_ppp</span><span class="p">,</span>
                    <span class="s1">&#39;N&#39;</span> <span class="p">:</span> <span class="n">N</span><span class="p">,</span>
                    <span class="s1">&#39;nsim&#39;</span> <span class="p">:</span> <span class="n">nsim</span>
                    <span class="p">}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;ppp_simulations_N_</span><span class="si">{}</span><span class="s1">_Nsim_</span><span class="si">{}</span><span class="s1">.mcsim&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">nsim</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ppp_simulation</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>   


    <span class="n">output_dic</span> <span class="o">=</span> <span class="n">compute_rank_envelope_test</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span>
                                         <span class="n">return_dic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                         <span class="n">ppp_sim</span><span class="o">=</span><span class="n">ppp_simulation</span><span class="p">[</span><span class="s1">&#39;list_ppp&#39;</span><span class="p">],</span>
                                         <span class="o">**</span><span class="n">test_params</span><span class="p">)</span>

    <span class="n">reject_H0</span> <span class="o">=</span> <span class="n">output_dic</span><span class="p">[</span><span class="s1">&#39;rejectH0&#39;</span><span class="p">]</span>
  
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reject_H0</span><span class="p">:</span>
        <span class="c1"># print(&#39;No detection.&#39;)</span>
        <span class="n">radius_of_rejection</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">radius_of_rejection</span> <span class="o">=</span> <span class="n">output_dic</span><span class="p">[</span><span class="s1">&#39;r_max_dif&#39;</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">radius_of_rejection</span></div>


<div class="viewcode-block" id="compute_global_mad_test"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.spatstats_utils.compute_global_mad_test">[docs]</a><span class="k">def</span> <span class="nf">compute_global_mad_test</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> 
                    <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">MC_reps</span> <span class="o">=</span> <span class="mi">199</span><span class="p">,</span> 
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> 
                    <span class="n">statistic</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">,</span>
                    <span class="n">pnorm</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> 
                    <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">rmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">one_sided</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">return_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute global MAD hypothesis tests based on Monte Carlo simulations.</span>

<span class="sd">    Args:</span>
<span class="sd">        signal (ndarray): Numpy ndarray with the signal.</span>
<span class="sd">        cs (ComputeStatistics, optional): This is an object of the ComputeStatistics</span>
<span class="sd">        class, that encapsulates the initialization of the spatstat-interface python</span>
<span class="sd">        package. This allows avoiding reinitialize the interface each time. </span>
<span class="sd">        Defaults to None.</span>
<span class="sd">        MC_reps (int, optional): Repetitions of the Monte Carlo simulations. </span>
<span class="sd">        Defaults to 199.</span>
<span class="sd">        alpha (float, optional): Significance of the tests. Defaults to 0.05.</span>
<span class="sd">        statistic (str, optional): Functional statistic computed on the point process </span>
<span class="sd">        determined by the zeros of spectrogram of the signal. Defaults to &#39;L&#39;.</span>
<span class="sd">        pnorm (int, optional): Summary statistics for the envelope-tests. Common values </span>
<span class="sd">        for this parameter are &quot;np.inf&quot; for the supremum norm, or &quot;2&quot; for the usual 2 </span>
<span class="sd">        norm. Defaults to 2.</span>
<span class="sd">        radius (float, optional): Vector of radius used for the computation of the </span>
<span class="sd">        functional statistics. Defaults to None.</span>
<span class="sd">        rmax (float, optional): Maximum radius to compute the test. One test per value </span>
<span class="sd">        in rmax is compute. If it is None, the values given in &quot;radius&quot; are used. </span>
<span class="sd">        Defaults to None.</span>
<span class="sd">        return_values (bool, optional): If False, returns a dictionary with the </span>
<span class="sd">        results of the test for each statistic and value of rmax. If True, also returns </span>
<span class="sd">        the empirical statistic and the simulated statistics. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Returns a dictionary with the results. If more than one statistic is </span>
<span class="sd">        given as input parameter, the dictionary will have one entry per statistic.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">Nfft</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">MC_reps</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="c1"># corresponding k value</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">statistic</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">statistic</span> <span class="o">=</span> <span class="p">(</span><span class="n">statistic</span><span class="p">,)</span>

    <span class="n">output_dict</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">compute_monte_carlo_sims</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span>
                                        <span class="n">cs</span><span class="p">,</span>
                                        <span class="n">Nfft</span><span class="p">,</span>
                                        <span class="n">MC_reps</span><span class="o">=</span><span class="n">MC_reps</span><span class="p">,</span>
                                        <span class="n">statistic</span><span class="o">=</span><span class="n">statistic</span><span class="p">,</span>
                                        <span class="n">pnorm</span><span class="o">=</span><span class="n">pnorm</span><span class="p">,</span>
                                        <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
                                        <span class="n">rmax</span><span class="o">=</span><span class="n">rmax</span><span class="p">,</span>
                                        <span class="n">one_sided</span><span class="o">=</span><span class="n">one_sided</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">sts</span> <span class="ow">in</span> <span class="n">statistic</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Sm</span><span class="p">,</span> <span class="n">Sexp</span><span class="p">,</span> <span class="n">S0</span> <span class="o">=</span> <span class="n">output_dict</span><span class="p">[</span><span class="n">sts</span><span class="p">]</span>

        <span class="c1"># Compute extreme values</span>
        <span class="n">texp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sexp</span><span class="o">-</span><span class="n">S0</span><span class="p">))</span>
        <span class="n">tsim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sm</span><span class="o">-</span><span class="n">S0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tsim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">tsim</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">texp</span> <span class="o">&gt;</span> <span class="n">tsim</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">reject_H0</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reject_H0</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">return_values</span><span class="p">:</span>
            <span class="n">output_dict</span><span class="p">[</span><span class="n">sts</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;reject_H0&#39;</span><span class="p">:</span> <span class="n">reject_H0</span><span class="p">,</span>
                                <span class="s1">&#39;Sm&#39;</span><span class="p">:</span><span class="n">Sm</span><span class="p">,</span>
                                <span class="s1">&#39;Sexp&#39;</span><span class="p">:</span><span class="n">Sexp</span><span class="p">,</span> 
                                <span class="s1">&#39;S0&#39;</span><span class="p">:</span><span class="n">S0</span><span class="p">,</span>
                                <span class="s1">&#39;texp&#39;</span> <span class="p">:</span> <span class="n">texp</span><span class="p">,</span>
                                <span class="s1">&#39;tsim&#39;</span> <span class="p">:</span> <span class="n">tsim</span><span class="p">,</span>
                                <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
                                <span class="s1">&#39;radius&#39;</span><span class="p">:</span><span class="n">radius</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_dict</span><span class="p">[</span><span class="n">sts</span><span class="p">]</span> <span class="o">=</span> <span class="n">reject_H0</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">statistic</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>    
        <span class="k">return</span> <span class="n">output_dict</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c1"># returns (tm, t_exp) if only one statistic was computed.</span>
        <span class="k">return</span> <span class="n">output_dict</span><span class="p">[</span><span class="n">statistic</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span></div>


    <span class="c1"># def spatialStatsFromR(pos):</span>

    <span class="c1"># # load spatstat</span>
    <span class="c1"># spatstat = importr(&#39;spatstat.geom&#39;)</span>
    <span class="c1"># spatstatCore = importr(&#39;spatstat.core&#39;)</span>

    <span class="c1"># u_r = robjects.FloatVector(pos[:, 0])</span>
    <span class="c1"># v_r = robjects.FloatVector(pos[:, 1])</span>

    <span class="c1"># bounds_u = np.array([np.min(pos[:, 0]), np.max(pos[:, 0])])</span>
    <span class="c1"># bounds_v = np.array([np.min(pos[:, 1]), np.max(pos[:, 1])])</span>

    <span class="c1"># b_u = robjects.FloatVector(bounds_u)</span>
    <span class="c1"># b_v = robjects.FloatVector(bounds_v)</span>

    <span class="c1"># ppp_r = spatstat.ppp(u_r, v_r, b_u, b_v)</span>

    <span class="c1"># K_r = spatstatCore.Kest(ppp_r)</span>
    <span class="c1"># L_r = spatstatCore.Lest(ppp_r)</span>
    <span class="c1"># pcf_r = spatstatCore.pcf(ppp_r)</span>

    <span class="c1"># radius = np.array(K_r[0])</span>
    <span class="c1"># Kborder = np.array(K_r[2])</span>

    <span class="c1"># if len(pos[:, 0]) &lt; 1024:</span>
    <span class="c1">#     Ktrans = np.array(K_r[3])</span>
    <span class="c1">#     Kiso = np.array(K_r[4])</span>

    <span class="c1">#     K = [Kborder, Ktrans, Kiso]</span>
    <span class="c1"># else:</span>
    <span class="c1">#     K = [Kborder]</span>

    <span class="c1"># Lborder = np.array(L_r[2])</span>
    <span class="c1"># Ltrans = np.array(L_r[3])</span>
    <span class="c1"># Liso = np.array(L_r[4])</span>

    <span class="c1"># L = [Lborder, Ltrans, Liso]</span>

    <span class="c1"># pcftrans = np.array(pcf_r[2])</span>
    <span class="c1"># pcfiso = np.array(pcf_r[3])</span>

    <span class="c1"># pcf = [pcftrans, pcfiso]</span>

    <span class="c1"># return radius, K, L, pcf</span>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Juan Manuel Miramont-Taurel.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>