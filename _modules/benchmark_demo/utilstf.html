<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>benchmark_demo.utilstf &mdash; Benchmark-demo  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Benchmark-demo
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Benchmark-demo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>benchmark_demo.utilstf</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for benchmark_demo.utilstf</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; This file contains a number of utilities for time-frequency analysis. </span>
<span class="sd">Some functions has been modified from the supplementary code of:</span>
<span class="sd">Bardenet, R., Flamant, J., &amp; Chainais, P. (2020). &quot;On the zeros of the spectrogram of </span>
<span class="sd">white noise.&quot; Applied and Computational Harmonic Analysis, 48(2), 682-705.</span>

<span class="sd">Those functions are:</span>
<span class="sd">- getSpectrogram(signal)</span>
<span class="sd">- findCenterEmptyBalls(Sww, pos_exp, radi_seg=1)</span>
<span class="sd">- getConvexHull(Sww, pos_exp, empty_mask, radi_expand=0.5)</span>
<span class="sd">- reconstructionSignal(hull_d, stft)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sg</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span> <span class="k">as</span> <span class="n">pi</span>

<div class="viewcode-block" id="get_round_window"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.get_round_window">[docs]</a><span class="k">def</span> <span class="nf">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generates a round Gaussian window, i.e. same essential support in time and </span>
<span class="sd">    frequency: g(n) = exp(-pi*(n/T)^2) for computing the Short-Time Fourier Transform.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        Nfft: Number of samples of the desired fft.</span>

<span class="sd">    Returns:</span>
<span class="sd">        g (ndarray): A round Gaussian window.</span>
<span class="sd">        T (float): The scale of the Gaussian window (T = sqrt(Nfft))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># analysis window</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">Nfft</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">T</span></div>


<div class="viewcode-block" id="get_stft"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.get_stft">[docs]</a><span class="k">def</span> <span class="nf">get_stft</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">window</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute the STFT of the signal. Signal is padded with zeros.</span>
<span class="sd">    The outputs corresponds to the STFT with the regular size and also the</span>
<span class="sd">    zero padded version. The signal is zero padded to alleviate border effects.</span>

<span class="sd">    Args:</span>
<span class="sd">        signal (ndarray): The signal to analyse.</span>
<span class="sd">        window (ndarray, optional): The window to use. If None, uses a rounded Gaussian</span>
<span class="sd">        window. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        stft(ndarray): Returns de stft of the signal.</span>
<span class="sd">        stft_padded(ndarray): Returns the stft of the zero-padded signal.</span>
<span class="sd">        Npad(int): Number of zeros padded on each side of the signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nfft</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">window</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>

    <span class="n">Npad</span> <span class="o">=</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">Nfft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
    <span class="n">signal_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">Npad</span><span class="p">)</span>
    <span class="n">signal_pad</span><span class="p">[</span><span class="n">Npad</span><span class="p">:</span><span class="n">Npad</span><span class="o">+</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span>
    <span class="c1"># computing STFT</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">stft_padded</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">signal_pad</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">noverlap</span> <span class="o">=</span> <span class="n">Nfft</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">stft</span> <span class="o">=</span> <span class="n">stft_padded</span><span class="p">[:,</span><span class="n">Npad</span><span class="p">:</span><span class="n">Npad</span><span class="o">+</span><span class="n">N</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">stft</span><span class="p">,</span> <span class="n">stft_padded</span><span class="p">,</span> <span class="n">Npad</span></div>


<div class="viewcode-block" id="get_spectrogram"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.get_spectrogram">[docs]</a><span class="k">def</span> <span class="nf">get_spectrogram</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the round spectrogram of the signal computed with a given window. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        signal(ndarray): A vector with the signal to analyse.</span>

<span class="sd">    Returns:</span>
<span class="sd">        S(ndarray): Spectrogram of the signal.</span>
<span class="sd">        stft: Short-time Fourier transform of the signal.</span>
<span class="sd">        stft_padded: Short-time Fourier transform of the padded signal.</span>
<span class="sd">        Npad: Number of zeros added in the zero-padding process.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nfft</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">window</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>

    <span class="n">stft</span><span class="p">,</span> <span class="n">stft_padded</span><span class="p">,</span> <span class="n">Npad</span> <span class="o">=</span> <span class="n">get_stft</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">stft</span><span class="p">,</span> <span class="n">stft_padded</span><span class="p">,</span> <span class="n">Npad</span></div>


<div class="viewcode-block" id="find_zeros_of_spectrogram"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.find_zeros_of_spectrogram">[docs]</a><span class="k">def</span> <span class="nf">find_zeros_of_spectrogram</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the zeros of the spectrogram by searching for minima in a 3x3 submatrix of</span>
<span class="sd">    the spectrogram.</span>

<span class="sd">    Args:</span>
<span class="sd">        S (ndarray): The spectrogram of a signal. </span>

<span class="sd">    Returns:</span>
<span class="sd">        pos(ndarray): A Mx2 array where each row contains the coordinates of a zero of </span>
<span class="sd">        the spectrogram.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># detection of zeros of the spectrogram</span>
    <span class="n">th</span> <span class="o">=</span> <span class="mf">1e-14</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">extr2minth</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">th</span><span class="p">)</span> <span class="c1"># Find zero&#39;s coordinates</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># Position of zeros in norm. coords.</span>
    <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
    <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="c1"># 2/15 Quedaron invertidos!!!!</span>
    <span class="k">return</span> <span class="n">pos</span></div>


<div class="viewcode-block" id="reconstruct_signal"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.reconstruct_signal">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_signal</span><span class="p">(</span><span class="n">hull_d</span><span class="p">,</span> <span class="n">stft</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reconstruction using the convex hull.</span>
<span class="sd">    This function is deprecated and conserved for retrocompatibility purposes only.</span>

<span class="sd">    Args:</span>
<span class="sd">        hull_d (_type_): _description_</span>
<span class="sd">        stft (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Nfft</span> <span class="o">=</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))</span>
    <span class="n">tmax</span> <span class="o">=</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">tmin</span>
    <span class="n">fmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))</span>
    <span class="n">fmax</span> <span class="o">=</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">fmin</span>

    <span class="c1"># sub mask : check which points are in the convex hull</span>
    <span class="n">vecx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))))</span>
    <span class="n">vecy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">vecx</span><span class="p">,</span> <span class="n">vecy</span><span class="p">))</span>
    <span class="n">sub_mask</span> <span class="o">=</span> <span class="n">hull_d</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">0</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">fmin</span><span class="p">:</span><span class="n">fmax</span><span class="p">,</span> <span class="n">tmin</span><span class="p">:</span><span class="n">tmax</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_mask</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mascara:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="c1"># create a mask</span>
    <span class="c1">#mask = np.zeros(stft.shape, dtype=bool)</span>
    <span class="c1">#mask[fmin:fmax, base+tmin:base+tmax] = sub_mask</span>

    <span class="c1"># reconstruction</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">Nfft</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">/</span><span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1"># t, xorigin = sg.istft(stft, window=g,  nperseg=Nfft, noverlap=Nfft-1)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">xr</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">mask</span><span class="o">*</span><span class="n">stft</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>  <span class="n">nperseg</span><span class="o">=</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">Nfft</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">t</span> </div>


<div class="viewcode-block" id="reconstruct_signal_2"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.reconstruct_signal_2">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_signal_2</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">stft</span><span class="p">,</span> <span class="n">Npad</span><span class="p">,</span> <span class="n">Nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reconstruction using a mask given as parameter</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (_type_): _description_</span>
<span class="sd">        stft (_type_): _description_</span>
<span class="sd">        Npad (_type_): _description_</span>
<span class="sd">        Nfft (_type_, optional): _description_. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Ni</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">Nfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nfft</span> <span class="o">=</span> <span class="n">Ni</span>
        
    <span class="c1"># reconstruction</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">Nfft</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">/</span><span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">mask_aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">mask_aux</span><span class="p">[:,</span><span class="n">Npad</span><span class="p">:</span><span class="n">Npad</span><span class="o">+</span><span class="n">Ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
    <span class="c1"># t, xorigin = sg.istft(stft, window=g,  nperseg=Nfft, noverlap=Nfft-1)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">xr</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">mask_aux</span><span class="o">*</span><span class="n">stft</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">noverlap</span> <span class="o">=</span> <span class="n">Nfft</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">xr</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="n">Npad</span><span class="p">:</span><span class="n">Npad</span><span class="o">+</span><span class="n">Ni</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">xr</span><span class="p">,</span> <span class="n">t</span></div>


<div class="viewcode-block" id="extr2minth"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.extr2minth">[docs]</a><span class="k">def</span> <span class="nf">extr2minth</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">th</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Finds the local minima of the spectrogram matrix M.</span>

<span class="sd">    Args:</span>
<span class="sd">        M (_type_): Matrix with real values.</span>
<span class="sd">        th (_type_): A given threshold.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">C</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Mid_Mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">C</span><span class="p">,</span><span class="n">R</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">C</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">Mid_Mid</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">th</span><span class="p">)</span>
            <span class="c1">#Mid_Mid[c, r] = (np.min(T) == T[1, 1])</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Mid_Mid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="snr_comparison"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.snr_comparison">[docs]</a><span class="k">def</span> <span class="nf">snr_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x_hat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Args:</span>
<span class="sd">        x (_type_): _description_</span>
<span class="sd">        x_hat (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">qrf</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x_hat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">qrf</span></div>


<div class="viewcode-block" id="add_snr_block"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.add_snr_block">[docs]</a><span class="k">def</span> <span class="nf">add_snr_block</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">snr</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds noise to a signal x with SNR equal to snr.</span>
<span class="sd">    SNR is defined as SNR (dB) = 10 * log10(Ex/En), where Ex and En are the energy of </span>
<span class="sd">    the signal and the noise, respectively.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (ndarray): Signal.</span>
<span class="sd">        snr (_type_): Signal-to-Noise Ratio in dB.</span>
<span class="sd">        K (int, optional): The number of noisy signals generated, vertically stacked. </span>
<span class="sd">        Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Block of shape [K,N], where K is the number of noisy signals, and N is </span>
<span class="sd">        length of the signal x.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># print(x)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">K</span><span class="p">)</span>
    <span class="c1"># n = n - np.mean(n,axis = 0)</span>
    <span class="c1"># print(np.mean(n, axis = 0))</span>
    <span class="c1"># x = x+n</span>

    <span class="n">Pn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>
    <span class="c1"># print(np.sum(n[:,0]**2))</span>

    <span class="n">Pn</span> <span class="o">=</span> <span class="n">Px</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span> <span class="n">snr</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>
    <span class="n">snr_out1</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
    <span class="n">snr_out</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Px</span> <span class="o">/</span> <span class="n">Pn</span><span class="p">)</span>
    <span class="c1"># print(snr_out)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">n</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">T</span></div>
    

<div class="viewcode-block" id="add_snr"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.add_snr">[docs]</a><span class="k">def</span> <span class="nf">add_snr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">snr</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds noise to a signal x with SNR equal to snr. SNR is defined as </span>
<span class="sd">    SNR (dB) = 10 * log10(Ex/En), where Ex and En are the energy of the signal and the </span>
<span class="sd">    noise, respectively.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (ndarray): Signal.</span>
<span class="sd">        snr (_type_): Signal-to-Noise Ratio in dB.</span>
<span class="sd">        K (int, optional): The number of noisy signals generated, vertically stacked. </span>
<span class="sd">        Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Block of shape [K,N], where K is the number of noisy signals, and N is </span>
<span class="sd">        length of the signal x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="c1"># n = n-np.mean(n)</span>
    
    <span class="n">Pn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>

    <span class="n">Pn</span> <span class="o">=</span> <span class="n">Px</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span> <span class="n">snr</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>
    <span class="c1"># snr_out1 = 20 * np.log10(np.sqrt(np.sum(x**2))/np.sqrt(np.sum(n**2)))</span>
    <span class="n">snr_out</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Px</span> <span class="o">/</span> <span class="n">Pn</span><span class="p">)</span>
    <span class="c1"># print(snr_out)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">n</span></div>


<div class="viewcode-block" id="hermite_poly"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.hermite_poly">[docs]</a><span class="k">def</span> <span class="nf">hermite_poly</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">return_all</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates a Hermite polynomial of order n on the vector t.</span>

<span class="sd">    Args:</span>
<span class="sd">        t (ndarray, float): A real valued vector on which compute the Hermite </span>
<span class="sd">        polynomials.</span>
<span class="sd">        n (int): Order of the Hermite polynomial.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Returns an array with the Hermite polynomial computed on t.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">all_hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),))</span>
        <span class="n">all_hp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span>

    <span class="k">else</span><span class="p">:</span>
            <span class="n">hp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span>
            <span class="n">all_hp</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),))</span>
            <span class="n">all_hp</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">hp</span>
            <span class="c1"># if n &gt;= 1:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># hp = 2*t*hermite_poly(t,n-1) - 2*(n-1)*hermite_poly(t,n-2)</span>
                <span class="n">hp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">hp</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_all</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hp</span><span class="p">,</span> <span class="n">all_hp</span></div>


<div class="viewcode-block" id="hermite_fun"><a class="viewcode-back" href="../../benchmark_demo.html#benchmark_demo.utilstf.hermite_fun">[docs]</a><span class="k">def</span> <span class="nf">hermite_fun</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_all</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes an Hermite function of order q, that consist in a centered Hermite </span>
<span class="sd">    polynomial multiplied by the squared-root of a centered Gaussian given by: </span>
<span class="sd">    exp(-pi(t/T)^2). The parameter T fixes the width of the Gaussian function.</span>

<span class="sd">    Args:</span>
<span class="sd">        N (int): Length of the function in samples</span>
<span class="sd">        q (int): Order of the Hermite polynomial.</span>
<span class="sd">        t (ndarray): Values on which compute the function. If None, uses a centered </span>
<span class="sd">        vector from -N//2 to N//2-1. Defaults to None.</span>
<span class="sd">        T (float): Scale of the Gaussian involved in the Hermite function. If None,</span>
<span class="sd">        N = sqrt(N). Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span>

    <span class="k">if</span> <span class="n">T</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">all_hp</span> <span class="o">=</span> <span class="n">hermite_poly</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">T</span><span class="p">,</span> <span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">return_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">gaussian_basic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">T</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="n">hfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="n">Cnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)))</span>
        <span class="c1"># gaussian_basic /= np.sum(gaussian_basic)</span>
        <span class="n">hfunc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaussian_basic</span><span class="o">*</span><span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">Cnorm</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_all</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hfunc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hfunc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">hfunc</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Juan Manuel Miramont-Taurel.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>